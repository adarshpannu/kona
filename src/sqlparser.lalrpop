use std::str::FromStr;
use lalrpop_util::ParseError;

use crate::expr::{Expr::*, *};
use crate::row::*;
use std::rc::Rc;
use std::cell::RefCell;
use crate::includes::*;
use crate::ast::{AST, NamedExpr, QueryBlock, QGM};

grammar;

CommaSeparatedList<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

SemicolonSeparatedList<T>: Vec<T> = {
    <mut v:(<T> ";")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

// -------------------- STATEMENTS --------------------
pub Job = SemicolonSeparatedList<Statement>;

pub Statement: AST = {
    <CatalogTable>,
    <DescribeTable>,
    <Query>
}

// -------------------- CATALOG TABLE --------------------
pub CatalogTable: AST = {
    "CATALOG" "TABLE" <name:Identifier> "(" <options:CatalogTableOptions> ")"  => AST::CatalogTable { name: name, options: options }
}

CatalogTableOptions = CommaSeparatedList<CatalogTableOption>;

CatalogTableOption: (String, String) = {
    <opt:QuotedString> "=" <val:QuotedString> => (opt, val)
}

// -------------------- DESCRIBE TABLE --------------------
pub DescribeTable: AST = {
    "DESCRIBE" "TABLE" <name:Identifier>  => AST::DescribeTable { name: name }
}

// -------------------- QUERY --------------------

pub Query: AST = {
    "SELECT" <select_list: SelectList> "FROM" <quns: FromList> "WHERE" <pred_list: LogExpr> => {
        let pred_list = vec![pred_list];
        let qblock = QueryBlock { select_list, quns, pred_list};
        let qgm = QGM { qblocks : vec![qblock] };
        AST::QGM(qgm)
    }
}

SelectList = CommaSeparatedList<NamedExpr>;

FromList = CommaSeparatedList<Identifier>;

NamedExpr: NamedExpr = <expr:ArithExpr> <name:("AS" Identifier)?> => NamedExpr { name: name.map(|e| e.1), expr };

pub LogExpr: ExprLink = {
    <LogExprFactor>,
    <l:LogExpr> "or" <r:LogExprFactor> => Rc::new(RefCell::new(Expr::LogExpr(l, LogOp::Or, r))),
}

LogExprFactor: ExprLink = {
    <l:LogExprFactor> "and" <r:RelExpr> => Rc::new(RefCell::new(Expr::LogExpr(l, LogOp::And, r))),
    RelExpr,
}

RelExpr: ExprLink = {
    <l:ArithExpr> <op:RelOp> <r:ArithExpr> => Rc::new(RefCell::new(Expr::RelExpr(l, op, r))),
    "(" <LogExpr> ")",
}

RelOp: RelOp = {
    ">" => RelOp::Gt,
    ">=" => RelOp::Ge,
    "<" => RelOp::Lt,
    "<=" => RelOp::Le,
    "!=" => RelOp::Ne,
    "=" => RelOp::Eq,
}

pub ArithExpr: ExprLink = {
    <l:ArithExpr> "+" <r:ArithFactor> => Rc::new(RefCell::new(Expr::ArithExpr(l, ArithOp::Add, r))),
    <l:ArithExpr> "-" <r:ArithFactor> => Rc::new(RefCell::new(Expr::ArithExpr(l, ArithOp::Sub, r))),
    ArithFactor,
}

ArithFactor: ExprLink = {
    <l:ArithFactor> "*" <r:Term> => Rc::new(RefCell::new(Expr::ArithExpr(l, ArithOp::Mul, r))),
    <l:ArithFactor> "/" <r:Term> => Rc::new(RefCell::new(Expr::ArithExpr(l, ArithOp::Div, r))),
    Term,
}

Term: ExprLink = {
    <cr:ColumnReference> => Rc::new(RefCell::new(Column { tablename: cr.0, colname: cr.1 } )),
    Num,
    "(" <ArithExpr> ")",
};

Num: ExprLink = {
    r"[0-9]+" =>? isize::from_str(<>)
    .map(|i| Rc::new(RefCell::new(Literal(Datum::INT(i)))))
    .map_err(|_| ParseError::User { error: "Invalid number" })
};

Identifier: String = {
    r"[a-zA-Z][a-zA-Z0-9]+" => <>.to_string()
}

ColumnReference: (Option<String>, String) = <tablename:(Identifier ".")?> <colname:Identifier> => (tablename.map(|e| e.0), colname);

QuotedString: String = {
    r#""[^"]*""# => {
        let s = <>;
        s[1..s.len()-1].to_string()
    }
}
