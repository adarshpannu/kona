use std::str::FromStr;
use lalrpop_util::ParseError;

use crate::expr::{Expr::*, *};
use crate::row::*;
use std::rc::Rc;
use std::cell::RefCell;
use crate::includes::*;
use crate::ast::AST;

grammar;

CommaSeparatedList<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

SemicolonSeparatedList<T>: Vec<T> = {
    <mut v:(<T> ";")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

// -------------------- JOB --------------------
pub Job = SemicolonSeparatedList<Statement>;

// -------------------- CATALOG TABLE --------------------
pub Statement: AST = {
    "CATALOG" "TABLE" <name:Identifier> "FROM" <filename:Filename> "(" <opts:Fileopts> ")"  => AST::CatalogTable { name: name, from: filename, opts: opts }
}

Filename: String = {
    QuotedString
}

Fileopts = CommaSeparatedList<Fileopt>;

Fileopt: (String, String) = {
    <opt:QuotedString> "=" <val:QuotedString> => (opt, val)
}

// -------------------- SELECT --------------------

pub LogExpr: Rc<RefCell<Expr>> = {
    <LogExprFactor>,
    <l:LogExpr> "or" <r:LogExprFactor> => Rc::new(RefCell::new(Expr::LogExpr(l, LogOp::Or, r))),
};

LogExprFactor: Rc<RefCell<Expr>> = {
    <l:LogExprFactor> "and" <r:RelExpr> => Rc::new(RefCell::new(Expr::LogExpr(l, LogOp::And, r))),
    RelExpr,
};

RelExpr: Rc<RefCell<Expr>> = {
    <l:ArithExpr> <op:RelOp> <r:ArithExpr> => Rc::new(RefCell::new(Expr::RelExpr(l, op, r))),
    "(" <LogExpr> ")",
};

RelOp: RelOp = {
    ">" => RelOp::Gt,
    ">=" => RelOp::Ge,
    "<" => RelOp::Lt,
    "<=" => RelOp::Le,
    "!=" => RelOp::Ne,
    "=" => RelOp::Eq,
};

pub ArithExpr: Rc<RefCell<Expr>> = {
    <l:ArithExpr> "+" <r:ArithFactor> => Rc::new(RefCell::new(Expr::ArithExpr(l, ArithOp::Add, r))),
    <l:ArithExpr> "-" <r:ArithFactor> => Rc::new(RefCell::new(Expr::ArithExpr(l, ArithOp::Sub, r))),
    ArithFactor,
};

ArithFactor: Rc<RefCell<Expr>> = {
    <l:ArithFactor> "*" <r:Term> => Rc::new(RefCell::new(Expr::ArithExpr(l, ArithOp::Mul, r))),
    <l:ArithFactor> "/" <r:Term> => Rc::new(RefCell::new(Expr::ArithExpr(l, ArithOp::Div, r))),
    Term,
};

Term: Rc<RefCell<Expr>> = {
    Identifier => Rc::new(RefCell::new(Identifier(<>))),
    Num,
    "(" <ArithExpr> ")",
};

Num: Rc<RefCell<Expr>> = {
    r"[0-9]+" =>? isize::from_str(<>)
    .map(|i| Rc::new(RefCell::new(Literal(Datum::INT(i)))))
    .map_err(|_| ParseError::User { error: "Invalid number" })
};

Identifier: String = {
    r"[a-zA-Z][a-zA-Z0-9]+" => String::from(<>)
}

QuotedString: String = {
    r#""[^"]*""# => String::from(<>)
}
