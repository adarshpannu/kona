use std::str::FromStr;
use lalrpop_util::ParseError;

use crate::expr::{Expr::*, *};
use crate::row::*;
use std::rc::Rc;
use std::cell::RefCell;
use crate::includes::*;
use crate::ast::{AST, NamedExpr, QueryBlock, QGM, ParserState, TableReference};

grammar(parser_state: &mut ParserState);

match {
    r"(?i)CATALOG" => "CATALOG",
    r"(?i)DESCRIBE" => "DESCRIBE",
    r"(?i)TABLE" => "TABLE",
    r"(?i)SELECT" => "SELECT",
    r"(?i)FROM" => "FROM",
    r"(?i)WHERE" => "WHERE",
    r"(?i)AND" => "AND",
    r"(?i)OR" => "OR",
    r"(?i)AS" => "AS",
    r"(?i)WITH" => "WITH",
    "(",
    ")",
    "=",
    "<",
    "<=",
    ">",
    ">=",
    "!=",
    "+",
    "-",
    "*",
    "/",
    r"[0-9]+",
    r#""[^"]*""#,
    ".",
    ",",
    ";",
    r"\s*" => { }, // The default whitespace skipping is disabled an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
} else {
    r"[a-zA-Z][a-zA-Z0-9]+",
}

CommaSeparatedList<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

SemicolonSeparatedList<T>: Vec<T> = {
    <mut v:(<T> ";")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

// -------------------- STATEMENTS --------------------
pub Job = SemicolonSeparatedList<Statement>;

pub Statement: AST = {
    <CatalogTable>,
    <DescribeTable>,
    <FullSelect>
}

// -------------------- CATALOG TABLE --------------------
pub CatalogTable: AST = {
    "CATALOG" "TABLE" <name:Identifier> "(" <options:CatalogTableOptions> ")"  => AST::CatalogTable { name: name, options: options }
}

CatalogTableOptions = CommaSeparatedList<CatalogTableOption>;

CatalogTableOption: (String, String) = {
    <opt:QuotedString> "=" <val:QuotedString> => (opt, val)
}

// -------------------- DESCRIBE TABLE --------------------
pub DescribeTable: AST = {
    "DESCRIBE" "TABLE" <name:Identifier>  => AST::DescribeTable { name: name }
}

// -------------------- QUERY --------------------

pub FullSelect: AST = <mut ctelist:WithClause?> <qblock:QueryBlock> => {
    let mut qblocks = vec![qblock];
    if let Some(mut ctelist) = ctelist {
        qblocks.append(&mut ctelist)
    }
    let qgm = QGM { qblocks };
    AST::QGM(qgm)
};

pub QueryBlock: QueryBlock = {
    "SELECT" <select_list: SelectList> "FROM" <quns: FromList> <pred_list: WhereClause?> => {
        let pred_list = if pred_list.is_some() { vec![pred_list.unwrap()] } else { vec![] };
        let qblock = QueryBlock { name: None, select_list, quns, pred_list};
        qblock
    }
};

WhereClause = "WHERE" <LogExpr>;

WithClause: Vec<QueryBlock> = "WITH" <CTEList>;

CTEList = CommaSeparatedList<CTE>;

CTE: QueryBlock = <name:Identifier> "AS" "(" <mut qblock: QueryBlock> ")" => { qblock.name = Some(name); qblock };

SelectList = CommaSeparatedList<NamedExpr>;

FromList = CommaSeparatedList<TableReference>;

TableReference: String = {
    Identifier => <>,
    "(" <mut qblock: QueryBlock> ")" correlation_clause? => "FOO".to_string() // TableReference::QueryBlock(qblock)
}

correlation_clause: String = "AS"? <id:Identifier> => id;

NamedExpr: NamedExpr = <expr:ArithExpr> <name:("AS" Identifier)?> => NamedExpr { name: name.map(|e| e.1), expr };

pub LogExpr: ExprLink = {
    <LogExprFactor>,
    <l:LogExpr> "OR" <r:LogExprFactor> => Rc::new(RefCell::new(Expr::LogExpr(l, LogOp::Or, r))),
}

LogExprFactor: ExprLink = {
    <l:LogExprFactor> "AND" <r:RelExpr> => Rc::new(RefCell::new(Expr::LogExpr(l, LogOp::And, r))),
    RelExpr,
}

RelExpr: ExprLink = {
    <l:ArithExpr> <op:RelOp> <r:ArithExpr> => Rc::new(RefCell::new(Expr::RelExpr(l, op, r))),
    "(" <LogExpr> ")",
}

RelOp: RelOp = {
    ">" => RelOp::Gt,
    ">=" => RelOp::Ge,
    "<" => RelOp::Lt,
    "<=" => RelOp::Le,
    "!=" => RelOp::Ne,
    "=" => RelOp::Eq,
}

pub ArithExpr: ExprLink = {
    <l:ArithExpr> "+" <r:ArithFactor> => Rc::new(RefCell::new(Expr::ArithExpr(l, ArithOp::Add, r))),
    <l:ArithExpr> "-" <r:ArithFactor> => Rc::new(RefCell::new(Expr::ArithExpr(l, ArithOp::Sub, r))),
    ArithFactor,
}

ArithFactor: ExprLink = {
    <l:ArithFactor> "*" <r:Term> => Rc::new(RefCell::new(Expr::ArithExpr(l, ArithOp::Mul, r))),
    <l:ArithFactor> "/" <r:Term> => Rc::new(RefCell::new(Expr::ArithExpr(l, ArithOp::Div, r))),
    Term,
}

Term: ExprLink = {
    <cr:ColumnReference> => Rc::new(RefCell::new(Column { tablename: cr.0, colname: cr.1 } )),
    Num,
    "(" <ArithExpr> ")",
};

Num: ExprLink = {
    r"[0-9]+" =>? isize::from_str(<>)
    .map(|i| Rc::new(RefCell::new(Literal(Datum::INT(i)))))
    .map_err(|_| ParseError::User { error: "Invalid number" })
};

Identifier: String = {
    r"[a-zA-Z][a-zA-Z0-9]+" => <>.to_string()
}

ColumnReference: (Option<String>, String) = <tablename:(Identifier ".")?> <colname:Identifier> => (tablename.map(|e| e.0), colname);

QuotedString: String = {
    r#""[^"]*""# => {
        let s = <>;
        s[1..s.len()-1].to_string()
    }
};
