use std::str::FromStr;
use lalrpop_util::ParseError;

use crate::expr::{Expr::*, *};
use crate::row::*;
use std::rc::Rc;
use std::cell::RefCell;
use crate::includes::*;
use crate::ast::AST;

grammar;

CommaSeparatedList<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

SemicolonSeparatedList<T>: Vec<T> = {
    <mut v:(<T> ";")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

// -------------------- STATEMENTS --------------------
pub Job = SemicolonSeparatedList<Statement>;

pub Statement: AST<'input> = {
    <CatalogTable>,
    <Query>
}

// -------------------- CATALOG TABLE --------------------
pub CatalogTable: AST<'input> = {
    "CATALOG" "TABLE" <name:Identifier> "(" <options:CatalogTableOptions> ")"  => AST::CatalogTable { name: name, options: options }
}

CatalogTableOptions = CommaSeparatedList<CatalogTableOption>;

CatalogTableOption: (&'input str, &'input str) = {
    <opt:QuotedString> "=" <val:QuotedString> => (opt, val)
}

// -------------------- QUERY --------------------

pub Query: AST<'input> = {
    "SELECT" <select_list: SelectList> "FROM" <from_list: FromList> "WHERE" <where_clause: LogExpr> => {
        AST::Query { select_list, from_list, where_clause }
    }
}

SelectList = CommaSeparatedList<ArithExpr>;

FromList = CommaSeparatedList<Identifier>;

pub LogExpr: ExprLink = {
    <LogExprFactor>,
    <l:LogExpr> "or" <r:LogExprFactor> => Rc::new(RefCell::new(Expr::LogExpr(l, LogOp::Or, r))),
}

LogExprFactor: ExprLink = {
    <l:LogExprFactor> "and" <r:RelExpr> => Rc::new(RefCell::new(Expr::LogExpr(l, LogOp::And, r))),
    RelExpr,
}

RelExpr: ExprLink = {
    <l:ArithExpr> <op:RelOp> <r:ArithExpr> => Rc::new(RefCell::new(Expr::RelExpr(l, op, r))),
    "(" <LogExpr> ")",
}

RelOp: RelOp = {
    ">" => RelOp::Gt,
    ">=" => RelOp::Ge,
    "<" => RelOp::Lt,
    "<=" => RelOp::Le,
    "!=" => RelOp::Ne,
    "=" => RelOp::Eq,
}

pub ArithExpr: ExprLink = {
    <l:ArithExpr> "+" <r:ArithFactor> => Rc::new(RefCell::new(Expr::ArithExpr(l, ArithOp::Add, r))),
    <l:ArithExpr> "-" <r:ArithFactor> => Rc::new(RefCell::new(Expr::ArithExpr(l, ArithOp::Sub, r))),
    ArithFactor,
}

ArithFactor: ExprLink = {
    <l:ArithFactor> "*" <r:Term> => Rc::new(RefCell::new(Expr::ArithExpr(l, ArithOp::Mul, r))),
    <l:ArithFactor> "/" <r:Term> => Rc::new(RefCell::new(Expr::ArithExpr(l, ArithOp::Div, r))),
    Term,
}

Term: ExprLink = {
    <cr:ColumnReference> => Rc::new(RefCell::new(Column { alias: cr.0, name: cr.1 } )),
    Num,
    "(" <ArithExpr> ")",
};

Num: ExprLink = {
    r"[0-9]+" =>? isize::from_str(<>)
    .map(|i| Rc::new(RefCell::new(Literal(Datum::INT(i)))))
    .map_err(|_| ParseError::User { error: "Invalid number" })
};

Identifier: &'input str = {
    r"[a-zA-Z][a-zA-Z0-9]+" => <>
}

ColumnReference: (Option<String>, String) = <alias:(Identifier ".")?> <col:Identifier> => (alias.map(|e| e.0.to_string()), col.to_string());

QuotedString: &'input str = {
    r#""[^"]*""# => {
        let s = <>;
        &s[1..s.len()-1]
    }
}