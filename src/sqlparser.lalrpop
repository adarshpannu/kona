use std::str::FromStr;
use lalrpop_util::ParseError;

use crate::includes::*;

use crate::ast::{Expr::*, *};
use crate::row::*;
use std::rc::Rc;
use std::cell::RefCell;
use crate::ast::{AST, NamedExpr, QueryBlock, QueryBlockType, QGM, ParserState, Quantifier};

grammar(parser_state: &mut ParserState);

match {
    r"(?i)CATALOG" => "CATALOG",
    r"(?i)DESCRIBE" => "DESCRIBE",
    r"(?i)TABLE" => "TABLE",
    r"(?i)SELECT" => "SELECT",
    r"(?i)FROM" => "FROM",
    r"(?i)WHERE" => "WHERE",
    r"(?i)GROUP" => "GROUP",
    r"(?i)ORDER" => "ORDER",
    r"(?i)HAVING" => "HAVING",
    r"(?i)ASC" => "ASC",
    r"(?i)DESC" => "DESC",
    r"(?i)BY" => "BY",
    r"(?i)AND" => "AND",
    r"(?i)OR" => "OR",
    r"(?i)AS" => "AS",
    r"(?i)WITH" => "WITH",
    r"(?i)NOT" => "NOT",
    r"(?i)EXISTS" => "EXISTS",
    r"(?i)DISTINCT" => "DISTINCT",
    r"(?i)IN" => "IN",
    r"(?i)ANY" => "ANY",
    r"(?i)ALL" => "ALL",
    r"(?i)LIKE" => "LIKE",
    r"(?i)BETWEEN" => "BETWEEN",
    r"(?i)MIN" => "MIN",
    r"(?i)MAX" => "MAX",
    r"(?i)SUM" => "SUM",
    r"(?i)COUNT" => "COUNT",
    r"(?i)AVG" => "AVG",
    r"(?i)CAST" => "CAST",
    r"(?i)TOP" => "TOP",
    "(",
    ")",
    "=",
    "<",
    "<=",
    ">",
    ">=",
    "!=",
    "<>",
    "+",
    "-",
    "*",
    "/",
    r"[-+]?[0-9]+",
    r"[-+]?\d*\.\d*",
    r#""[^"]*""#,
    r#"'[^']*'"#,
    ".",
    ",",
    ";",
    r"\s*" => { }, // The default whitespace skipping is disabled an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip // comments
    r"--[^\n\r]*[\n\r]*" => { }, // Skip -- comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
} else {
    r"[a-zA-Z][a-zA-Z0-9_-]*",
}

CommaSeparatedList<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

SemicolonSeparatedList<T>: Vec<T> = {
    <mut v:(<T> ";")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

// -------------------- STATEMENTS --------------------
pub Job = SemicolonSeparatedList<Statement>;

pub Statement: AST = {
    <CatalogTable>,
    <DescribeTable>,
    <FullSelect>
}

// -------------------- CATALOG TABLE --------------------
pub CatalogTable: AST = {
    "CATALOG" "TABLE" <name:Identifier> "(" <options:CatalogTableOptions> ")"  => AST::CatalogTable { name: name, options: options }
}

CatalogTableOptions = CommaSeparatedList<CatalogTableOption>;

CatalogTableOption: (String, String) = {
    <opt:QuotedString> "=" <val:QuotedString> => (opt, val)
}

// -------------------- DESCRIBE TABLE --------------------
pub DescribeTable: AST = {
    "DESCRIBE" "TABLE" <name:Identifier>  => AST::DescribeTable { name: name }
}

// -------------------- QUERY --------------------

pub FullSelect: AST = <mut ctelist:WithClause?> <mut qblock:QueryBlock> => {
    let mut qblocks: Vec<QueryBlockLink> = vec![];
    if let Some(mut ctelist) = ctelist {
        qblocks.append(&mut ctelist)
    }

    qblock.name = Some(String::from("main"));
    qblock.qbtype = QueryBlockType::Main;
    qblock.qblocks = qblocks;

    let qgm = QGM { qblock };
    AST::QGM(qgm)
};

pub QueryBlock: QueryBlock = {
    "SELECT" TopN? AllOrDistinct? <select_list: SelectList> "FROM" <mut quns: FromList> <pred_list: WhereClause?> GroupByClause? HavingClause? OrderByClause?  => {
        let pred_list = if pred_list.is_some() { vec![pred_list.unwrap()] } else { vec![] };
        QueryBlock::new(parser_state.next_id(), None, QueryBlockType::Subquery, select_list, quns, pred_list, vec![])
    }
};

Subquery: QueryBlockLink = "(" <qblock:QueryBlock> ")" => {
    let subq = Rc::new(RefCell::new(qblock));
    parser_state.add_subquery(subq.clone());
    subq
};

TopN = "TOP" Integer;

AllOrDistinct = {
    "ALL",
    "DISTINCT"
}

WithClause = "WITH" <CTEList>;

CTEList = CommaSeparatedList<CTE>;

CTE: QueryBlockLink = <name:Identifier> "AS" <mut subqlink:Subquery> => {
    let mut subq = &mut *subqlink.borrow_mut();
    subq.name = Some(name);
    subqlink.clone()
};

SelectList = CommaSeparatedList<NamedExpr>;

FromList = CommaSeparatedList<Quantifier>;

WhereClause = "WHERE" <LogExpr>;

GroupByClause = "GROUP" "BY" CommaSeparatedList<Expr>;

HavingClause = "HAVING" <LogExpr>;

OrderByClause = "ORDER" "BY" CommaSeparatedList<OrderCol>;

OrderCol = Expr OrderSort?;

OrderSort = {
    "ASC",
    "DESC"
}

Quantifier: Quantifier = {
    <schemaname:(Identifier ".")?> <name:Identifier> <alias:correlation_clause?> => {
        Quantifier::new(parser_state.next_id(), Some(name), alias, None)
    },
    <subq:Subquery> <alias:correlation_clause?> => {
        Quantifier::new(parser_state.next_id(), None, alias, Some(subq))
    }
}

correlation_clause: String = "AS"? <id:Identifier> => id;

NamedExpr: NamedExpr = {
    "*" => NamedExpr::new(None, Expr::newlink(Expr::Star)),
    <expr:Expr> <name:("AS" Identifier)?> => NamedExpr::new(name.map(|e| e.1), expr)
}

pub LogExpr: ExprLink = {
    <LogExprFactor>,
    <l:LogExpr> "OR" <r:LogExprFactor> => Expr::newlink(Expr::LogExpr(l, LogOp::Or, Some(r))),
}

LogExprFactor: ExprLink = {
    <l:LogExprFactor> "AND" <r:RelExpr> => Expr::newlink(Expr::LogExpr(l, LogOp::And, Some(r))),
    RelExpr,
}

RelExpr: ExprLink = {
    <l:Expr> <op:RelOp> <r:RelExprRHS> => Expr::newlink(RelExpr(l, op, r)),
    <e:Expr> "BETWEEN" <l:Expr> "AND" <r:Expr> => Expr::newlink(BetweenExpr(e, l, r)),
    <e:Expr> <not:"NOT"?> "IN" <mut inexpr:InExprRHS> => {
        let expr = if inexpr.0 {
            let subq = inexpr.1.pop().unwrap();
            Expr::newlink(Expr::InSubqExpr(e, subq))
        } else {
            let args = inexpr.1;
            Expr::newlink(Expr::InListExpr(e, args))
        };
        if not.is_some() {
            Expr::newlink(Expr::LogExpr(expr, LogOp::Not, None))
        } else {
            expr
        }
    },
    "EXISTS" <subq:Subquery> => { 
        let subq = Expr::newlink(Subquery(subq));
        Expr::newlink(ExistsExpr(subq))
    },
    "NOT" <e:RelExpr> => Expr::newlink(Expr::LogExpr(e, LogOp::Not, None)),
    "(" <LogExpr> ")",
}

RelExprRHS: ExprLink = {
    <rhs:Expr> => rhs,
    <prefix:SubqueryQuantifier> <subq:Subquery> => { 
        Expr::newlink(Subquery(subq))
    }
}

RelOp: RelOp = {
    ">" => RelOp::Gt,
    ">=" => RelOp::Ge,
    "<" => RelOp::Lt,
    "<=" => RelOp::Le,
    "!=" => RelOp::Ne,
    "<>" => RelOp::Ne,
    "=" => RelOp::Eq,
    "LIKE" => RelOp::Like,
    "NOT" "LIKE" => RelOp::Like, // FIXME
}

InExprRHS: (bool, Vec<ExprLink>) = {
    <subq:Subquery> => { 
        (true, vec![Expr::newlink(Subquery(subq))])
    },
    "(" <InList> ")" => (false, <>)
}

InList = CommaSeparatedList<Expr>;

SubqueryQuantifier = {
    "ALL",
    "ANY",
}

pub Expr: ExprLink = {
    <l:Expr> "+" <r:Factor> => Expr::newlink(BinaryExpr(l, ArithOp::Add, r)),
    <l:Expr> "-" <r:Factor> => Expr::newlink(BinaryExpr(l, ArithOp::Sub, r)),
    Factor,
}

Factor: ExprLink = {
    <l:Factor> "*" <r:Term> => Expr::newlink(BinaryExpr(l, ArithOp::Mul, r)),
    <l:Factor> "/" <r:Term> => Expr::newlink(BinaryExpr(l, ArithOp::Div, r)),
    Term,
}

Term: ExprLink = {
    <cr:ColumnReference> => Expr::newlink(Column { tablename: cr.0, colname: cr.1 } ),
    QuotedString => { Expr::newlink(Literal(Datum::STR(Box::new(<>)))) },
    Number,
    ScalarFunction,
    AggFunction,
    "-" <Term> => Expr::newlink(NegatedExpr(<>)),
    "(" <Expr> ")",
    <subq:Subquery> => { 
        Expr::newlink(Subquery(subq))
    }
}

AggFunction: ExprLink = {
    <aggtype:AggName> "(" <arg:AggArg> ")" => Expr::newlink(AggFunction { aggtype, arg }),
    "COUNT" "(" <distinct:"DISTINCT"?> <arg:AggArg> ")" => {
        let aggtype = if distinct.is_some() { AggType::COUNT_DISTINCT } else { AggType::COUNT };
        Expr::newlink(AggFunction { aggtype, arg }) 
    }
}

AggName: AggType = {
    "MIN" => AggType::MIN,
    "MAX" => AggType::MAX, 
    "SUM" => AggType::SUM, 
    "AVG" => AggType::AVG
}

AggArg: ExprLink = {
    <arg:Expr> => arg,
    "*" => Expr::newlink(Expr::Star)
}

ScalarFunction: ExprLink = {
    <name:Identifier> "(" <args:FunctionArgs> ")" => Expr::newlink(ScalarFunction { name, args }),
    "CAST" "(" <arg:Expr> "AS" <datatype:Identifier> ")" => {
        let datatype = Expr::newlink(Literal(Datum::STR(Box::new(datatype.to_string()))));
        let args = vec![arg, datatype];
        Expr::newlink(ScalarFunction { name: "CAST".to_string(), args })
    }
}

FunctionArgs = CommaSeparatedList<Expr>;

Number: ExprLink = {
    Integer =>? { isize::from_str(<>)
        .map(|i| Expr::newlink(Literal(Datum::INT(i))))
        .map_err(|_| ParseError::User { error: "Invalid integer" }) 
    },
    Double =>? { f64::from_str(<>)
        .map(|d| Expr::newlink(Literal(Datum::DOUBLE(111, 222))))
        .map_err(|_| ParseError::User { error: "Invalid double" }) 
    },
}

Integer = r"[-+]?[0-9]+";

Double = r"[-+]?\d*\.\d*";

Identifier: String = {
    r"[a-zA-Z][a-zA-Z0-9_-]*" => <>.to_string()
}

ColumnReference: (Option<String>, String) = <tablename:(Identifier ".")?> <colname:Identifier> => (tablename.map(|e| e.0), colname);

QuotedString: String = {
    r#""[^"]*""# => {
        let s = <>;
        s[1..s.len()-1].to_string()
    },
    r#"'[^']*'"# => {
        let s = <>;
        s[1..s.len()-1].to_string()
    }
}
